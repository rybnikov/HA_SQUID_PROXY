# Release 1.2.1: Security Hardening

## Overview
Comprehensive security hardening across container, process, data, and API layers to align with security best practices and reduce attack surface.

---

## Phase 1: High-Impact / Quick Wins

### 1.1 Container Image Hardening

**Non-root user in addon container**
- Verify `USER 1000:1000` in main Dockerfile (not just Squid)
- Ensure all Python files writable only by uid 1000
- Config/logs directories owned by 1000:1000

**Drop capabilities in docker-compose / HA addon config**
```yaml
# squid_proxy_manager/config.yaml
cap_drop:
  - ALL
cap_add:
  - NET_BIND_SERVICE  # Only if needed for port < 1024
```

**Read-only root filesystem (where possible)**
```yaml
read_only: true
tmpfs:
  - /tmp
  - /run
```

**Security scanning in CI**
- Add Trivy or Anchore scan to pre-commit/Actions
- Block releases with HIGH/CRITICAL CVEs

**Files to modify**:
- `squid_proxy_manager/Dockerfile` (main addon image)
- `squid_proxy_manager/config.yaml` (add cap_drop, read_only, tmpfs)
- `.github/workflows/` (add security scan job)

---

### 1.2 File Permissions & Ownership

**Audit all file creation**
```python
# squid_proxy_manager/rootfs/app/proxy_manager.py
# When creating instance directories:
instance_dir.mkdir(mode=0o750, parents=True, exist_ok=True)  # rwxr-x---
config_file.chmod(0o640)  # rw-r-----  (not 0o644)
passwd_file.chmod(0o640)  # rw-r-----  (not world-readable)
cert_file.chmod(0o640)    # rw-r-----
key_file.chmod(0o640)     # rw-r-----
```

**Verify Squid user can still read (integration test)**
- Run Squid as uid 100/gid 101 (typical squid user)
- Test: Squid can read config, passwd, cert, key with 0o640 perms
- Add integration test: `test_squid_can_read_instance_files_with_restricted_perms()`

**Temp cache/log directories should be 0o700 (rwx------)**
- Add `umask 0o077` in Python startup

**Files to modify**:
- `squid_proxy_manager/rootfs/app/proxy_manager.py` (file creation)
- `tests/integration/test_file_permissions.py` (new test)

---

### 1.3 Secrets Management

**Audit logging for secrets (grep in code + CI)**
```bash
# Add to pre-commit:
- repo: https://github.com/Yelp/detect-secrets
  rev: v1.4.0
  hooks:
    - id: detect-secrets
      args: ['--baseline', '.secrets.baseline']
```

**Redact passwords in API responses**
```python
# main.py - GET /api/instances/{name}/users
# Return only usernames, never passwords
response = {
    'users': [
        {'username': user, 'added_at': timestamp}  # No password!
    ]
}
```

**Redact passwords in logs**
```python
# proxy_manager.py
import logging
logger = logging.getLogger(__name__)

# Log without exposing password:
logger.info(f"User added to instance: {name}/{username}")
# NOT: logger.info(f"User added: {name}/{username}/{password}")
```

**Add structured logging with masking** (optional, for audit trail)
- Use `pythonjsonlogger` for structured logs
- Add `password_hash` only (never plaintext)

**Files to modify**:
- `.pre-commit-config.yaml` (add detect-secrets)
- `squid_proxy_manager/rootfs/app/main.py` (redact responses)
- `squid_proxy_manager/rootfs/app/proxy_manager.py` (redact logs)
- Add `.secrets.baseline` for known safe hashes

---

### 1.4 Input Validation & Injection Prevention

**Validate instance names** (alphanumeric + underscore only)
```python
# proxy_manager.py
import re

def validate_instance_name(name: str) -> None:
    if not re.match(r'^[a-zA-Z0-9_-]{1,64}$', name):
        raise ValueError(f"Invalid instance name: {name}")
```

**Validate usernames** (same pattern)
```python
# auth_manager.py
def validate_username(username: str) -> None:
    if not re.match(r'^[a-zA-Z0-9_@.-]{1,64}$', username):
        raise ValueError(f"Invalid username: {username}")
```

**Validate ports** (1024â€“65535, not reserved)
```python
def validate_port(port: int) -> None:
    if not 1024 <= port <= 65535:
        raise ValueError(f"Port out of range: {port}")
    # Optionally block reserved ports (3306, 5432, etc.)
```

**Use parameterized config generation** (not string concatenation)
```python
# WRONG:
config_lines.append(f"auth_param basic realm {realm}")

# CORRECT:
config_lines.append(f"auth_param basic realm {shlex.quote(realm)}")
```

**Add unit tests for injection attempts**
```python
@pytest.mark.unit
def test_reject_instance_name_with_path_traversal():
    with pytest.raises(ValueError):
        manager.create_instance(name="../etc/passwd")
```

**Files to modify**:
- `squid_proxy_manager/rootfs/app/proxy_manager.py` (add validators)
- `squid_proxy_manager/rootfs/app/auth_manager.py` (add validators)
- `squid_proxy_manager/rootfs/app/squid_config.py` (use shlex.quote)
- `tests/unit/test_input_validation.py` (new test file)

---

## Phase 2: Medium-Impact / Medium Effort

### 2.1 API Security: CORS & Rate Limiting

**Add CORS headers** (only allow HA ingress origin)
```python
# main.py
async def cors_middleware(app, handler):
    async def middleware_handler(request):
        if request.method == 'OPTIONS':
            return web.Response(
                headers={
                    'Access-Control-Allow-Origin': 'http://localhost:8123',
                    'Access-Control-Allow-Methods': 'GET, POST, DELETE, PATCH',
                    'Access-Control-Allow-Headers': 'Content-Type',
                }
            )
        response = await handler(request)
        response.headers['Access-Control-Allow-Origin'] = 'http://localhost:8123'
        return response
    return middleware_handler

app.middlewares.append(cors_middleware)
```

**Add rate limiting** (on per-endpoint basis)
```python
from aiolimiter import AsyncLimiter

limiter = AsyncLimiter(max_rate=10, time_period=60)  # 10 reqs/min

async def handle_add_user(request):
    async with limiter:
        # ... add user logic
```

**Add request timeout** (prevent slow-client attacks)
```python
app = web.Application(
    client_max_size=1_048_576,  # 1 MB
)
# Set timeout in handler or middleware
```

**Files to modify**:
- `squid_proxy_manager/rootfs/app/main.py` (add CORS, rate limiter)
- `requirements.txt` (add aiolimiter)

---

### 2.2 Authentication & Authorization

**Add Bearer token validation** (from HA Supervisor)
```python
# main.py
SUPERVISOR_TOKEN = os.environ.get('SUPERVISOR_TOKEN')

async def auth_middleware(app, handler):
    async def middleware_handler(request):
        if request.path.startswith('/api/'):
            auth_header = request.headers.get('Authorization', '')
            expected = f'Bearer {SUPERVISOR_TOKEN}'
            if auth_header != expected:
                return web.json_response(
                    {'error': 'Unauthorized'},
                    status=401
                )
        response = await handler(request)
        return response
    return middleware_handler
```

**Verify SUPERVISOR_TOKEN is set in config.yaml**
```yaml
# squid_proxy_manager/config.yaml
environment:
  SUPERVISOR_TOKEN: "{{ env.SUPERVISOR_TOKEN }}"
```

**Files to modify**:
- `squid_proxy_manager/rootfs/app/main.py` (add token validation)
- `squid_proxy_manager/config.yaml` (ensure token passed)

---

### 2.3 HTTPS & TLS Hardening

**Add HSTS header** to API responses
```python
# main.py
response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
```

**Add secure cookie flags** (if using cookies)
```python
# main.py
response.set_cookie('session', value, secure=True, httponly=True, samesite='Strict')
```

**Force modern TLS versions in Squid config**
```python
# squid_config.py
https_line = f"https_port {port} tls-cert={cert_file} tls-key={key_file} " \
            f"options=NO_SSLv3:NO_TLSv1:NO_TLSv1_1"
config_lines.append(https_line)
```

**Certificate validation in integration tests**
- Verify cert is self-signed but valid PEM
- Verify CN matches instance name
- Verify no weak key sizes (RSA < 2048 bits)

**Files to modify**:
- `squid_proxy_manager/rootfs/app/main.py` (add HSTS, secure cookies)
- `squid_proxy_manager/rootfs/app/squid_config.py` (TLS options)
- `tests/integration/test_https_tls.py` (new cert validation tests)

---

## Phase 3: Long-Term / Advanced

### 3.1 Audit Logging

**Add audit log table** (SQLite or JSON lines)
```python
# audit_logger.py
import json
import asyncio
from datetime import datetime

class AuditLogger:
    def __init__(self, log_file: str):
        self.log_file = log_file

    async def log_action(self, action: str, target: str, status: str, details: dict = None):
        entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'action': action,
            'target': target,
            'status': status,
            'details': details or {}
        }
        async with aiofiles.open(self.log_file, 'a') as f:
            await f.write(json.dumps(entry) + '\n')
```

**Log all API actions**
- Instance create/update/delete
- User add/remove
- Certificate regenerate
- Proxy start/stop

**Expose audit logs via read-only API endpoint**
```python
# main.py
async def handle_audit_logs(request):
    logs = await audit_logger.read_logs(limit=100)
    return web.json_response(logs)
```

**Files to create**:
- `squid_proxy_manager/rootfs/app/audit_logger.py` (new)
- Update `main.py` to call audit logger

---

### 3.2 Secrets Rotation & Certificate Lifecycle

**Certificate expiry alerts** (in UI + logs)
```python
# cert_manager.py
def get_cert_expiry_warning(cert_path: Path) -> Optional[str]:
    cert = x509.load_pem_x509_certificate(cert_path.read_bytes())
    days_until_expiry = (cert.not_valid_after - datetime.utcnow()).days
    if days_until_expiry < 30:
        return f"Certificate expires in {days_until_expiry} days"
    return None
```

**Automated certificate regeneration** (optional, advanced)
- Background task to check expiry every 24h
- Regenerate if < 7 days until expiry
- Log action in audit trail

**Files to modify**:
- `squid_proxy_manager/rootfs/app/cert_manager.py` (add expiry check)
- `squid_proxy_manager/rootfs/app/main.py` (add background task)

---

### 3.3 Network Isolation & Firewall Rules

**Document network policies** in HA addon config
```yaml
# squid_proxy_manager/config.yaml
network_mode: bridge
ports:
  - 8099:8099/tcp  # Only API server, not Squid instances
# Squid instances use host networking (inherited from container)
```

**Add optional allow-list for upstream proxies** (future feature)
- Restrict which upstream proxies Squid can connect to

---

### 3.4 Dependency Scanning & SBOM

**Add pip-audit to CI**
```bash
# .github/workflows/security.yml
- name: Run pip-audit
  run: pip-audit requirements.txt --fix
```

**Generate SBOM** (CycloneDX format)
```bash
- name: Generate SBOM
  run: cyclonedx-bom -o requirements.txt --output-file sbom.xml
```

**Pin all dependencies** (no floating versions)
```
# requirements.txt
aiohttp==3.9.1  # NOT: aiohttp>=3.8
cryptography==41.0.7
passlib==1.7.4
```

**Files to modify**:
- `requirements.txt` (pin versions)
- `.github/workflows/security.yml` (add pip-audit, SBOM)

---

## Testing Strategy

All security changes require tests:

```bash
# Unit tests for validators
./run_tests.sh tests/unit/test_input_validation.py -v

# Integration tests for file permissions
./run_tests.sh tests/integration/test_file_permissions.py -v

# E2E test for API auth (if applicable)
./run_tests.sh tests/e2e/ -v -k "test_api_auth"

# Full test suite before release
./run_tests.sh
```

---

## CI / Release Gates

Update `TEST_PLAN.md` to include security gates:

```yaml
# .github/workflows/security.yml (new)
Security:
  - Trivy scan (no HIGH/CRITICAL)
  - Bandit analysis
  - pip-audit (no known vulns)
  - detect-secrets (no plaintext secrets)
  - Pre-commit hooks (all pass)
```

---

## Recommended Priority Order

**Start with Phase 1** (high ROI):
1. Container hardening (1.1)
2. File permissions (1.2)
3. Secrets redaction (1.3)
4. Input validation (1.4)

**Then Phase 2** (medium ROI):
5. CORS + rate limiting (2.1)
6. Bearer token auth (2.2)
7. TLS hardening (2.3)

**Phase 3** (nice to have):
8. Audit logging (3.1)
9. Cert expiry (3.2)
10. Dependency scanning (3.4)

---

## Implementation Status

- [ ] Phase 1.1: Container Image Hardening
- [ ] Phase 1.2: File Permissions & Ownership
- [ ] Phase 1.3: Secrets Management
- [ ] Phase 1.4: Input Validation & Injection Prevention
- [ ] Phase 2.1: API Security: CORS & Rate Limiting
- [ ] Phase 2.2: Authentication & Authorization
- [ ] Phase 2.3: HTTPS & TLS Hardening
- [ ] Phase 3.1: Audit Logging
- [ ] Phase 3.2: Secrets Rotation & Certificate Lifecycle
- [ ] Phase 3.3: Network Isolation & Firewall Rules
- [ ] Phase 3.4: Dependency Scanning & SBOM
