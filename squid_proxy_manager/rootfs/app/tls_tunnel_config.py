#!/usr/bin/env python3
"""TLS Tunnel (nginx SNI multiplexer) configuration generation."""

from __future__ import annotations

import logging
import re
from pathlib import Path

_LOGGER = logging.getLogger(__name__)

DEFAULT_DATA_DIR = "/data/squid_proxy_manager"

# Instance name validation (same pattern as proxy_manager.py)
INSTANCE_NAME_RE = re.compile(r"^[a-z0-9][a-z0-9._-]{0,63}$")

# Validation for forward_address: host or host:port format
# Port is optional - defaults to 443 if not specified
FORWARD_ADDRESS_RE = re.compile(r"^[a-zA-Z0-9._-]+(:\d{1,5})?$")


def normalize_forward_address(address: str) -> str:
    """Normalize forward_address to always include port.

    If port is not specified, defaults to 443 (HTTPS).
    Returns address in hostname:port format.
    """
    if ":" not in address:
        return f"{address}:443"
    return address


def validate_forward_address(address: str) -> None:
    """Validate forward_address format (host or host:port).

    Port is optional - defaults to 443 (HTTPS) if not specified.
    """
    if not FORWARD_ADDRESS_RE.match(address):
        raise ValueError(
            f"Invalid forward address: {address}. "
            "Expected format: hostname or hostname:port (e.g., vpn.example.com or vpn.example.com:1194)"
        )

    # Validate port if provided
    if ":" in address:
        _, port_str = address.rsplit(":", 1)
        port = int(port_str)
        if not 1 <= port <= 65535:
            raise ValueError(f"Port out of range in forward address: {port}")


class TlsTunnelConfigGenerator:
    """Generates nginx stream config for TLS tunnel instances."""

    def __init__(
        self,
        instance_name: str,
        listen_port: int,
        forward_address: str,
        cover_site_port: int,
        data_dir: str = DEFAULT_DATA_DIR,
        rate_limit: int = 10,
    ) -> None:
        # Validate instance name to prevent path traversal
        import os

        instance_name = os.path.basename(instance_name)  # CodeQL path-injection sanitiser
        if not INSTANCE_NAME_RE.match(instance_name):
            raise ValueError(
                f"Invalid instance name: {instance_name}. " "Must be 1-64 chars of a-z, 0-9, _, -"
            )
        self.instance_name = instance_name
        self.listen_port = listen_port
        # Normalize forward_address to always include port (default 443)
        self.forward_address = normalize_forward_address(forward_address)
        self.cover_site_port = cover_site_port
        self.data_dir = data_dir
        self.rate_limit = rate_limit

    def generate_stream_config(
        self, config_file: Path, cover_config_path: Path | None = None
    ) -> None:
        """Generate nginx stream config for SNI multiplexing.

        Uses ssl_preread to detect TLS ClientHello (first byte 0x16).
        Non-TLS traffic (OpenVPN with tls-crypt) is forwarded to the VPN server.
        TLS traffic (DPI probes, browsers) is forwarded to the cover website.

        Uses resolver + variable-based proxy_pass so nginx does not require
        DNS resolution of the VPN server at startup time. This allows the tunnel
        to start even when the VPN hostname is temporarily unreachable.

        Args:
            config_file: Path to write the stream config.
            cover_config_path: If provided, adds an include directive so the
                cover-site HTTP block is loaded by the same nginx process.
        """
        import os as _os

        # Re-apply basename in local scope so CodeQL sees the sanitiser
        _inst = _os.path.basename(self.instance_name)  # CodeQL path-injection sanitiser

        # Sanitize instance name for use in nginx config identifiers
        safe_name = re.sub(r"[^a-zA-Z0-9_]", "_", _inst)

        # Instance-local pid path (app user cannot write to /run/nginx/)
        instance_dir = Path(self.data_dir) / _inst
        pid_path = instance_dir / "nginx.pid"
        log_dir = Path(self.data_dir) / "logs" / _inst

        config = f"""# TLS Tunnel: {self.instance_name}
# Auto-generated by Squid Proxy Manager — do not edit manually
#
# How it works:
#   - ssl_preread inspects the first bytes of each TCP connection
#   - If first byte is 0x16 (TLS ClientHello) → route to cover website
#   - If first byte is NOT 0x16 (OpenVPN tls-crypt) → route to VPN server
#   - DPI active probes see a legitimate HTTPS website

load_module /usr/lib/nginx/modules/ngx_stream_module.so;

pid {pid_path};

# Error log for nginx stream errors
error_log {log_dir}/nginx.log warn;

events {{
    worker_connections 1024;
}}

stream {{
    # Resolver for runtime DNS lookups (VPN server may be a hostname).
    # Using local DNS with fallback; valid=30s caches results briefly.
    resolver 127.0.0.11 8.8.8.8 valid=30s ipv6=off;
    resolver_timeout 5s;

    # Rate limiting: limit concurrent connections per source IP
    limit_conn_zone $remote_addr zone=conn_limit_{safe_name}:10m;

    # Map based on ssl_preread_protocol detection
    # Empty string = not TLS = OpenVPN tls-crypt traffic
    map $ssl_preread_protocol $backend_{safe_name} {{
        ""       {self.forward_address};
        default  127.0.0.1:{self.cover_site_port};
    }}

    server {{
        listen {self.listen_port};
        ssl_preread on;
        proxy_pass $backend_{safe_name};
        proxy_connect_timeout 5s;
        proxy_timeout 86400s;

        # Limit concurrent connections per IP
        limit_conn conn_limit_{safe_name} {self.rate_limit};
    }}
}}
"""
        # Include cover-site HTTP block so one nginx process serves both
        if cover_config_path is not None:
            config += f"\ninclude {cover_config_path};\n"

        # Security audit: config_file from caller's _safe_path(CONFIG_DIR, name) + literal suffix.
        # instance_name validated by os.path.basename() + regex ^[a-z0-9][a-z0-9._-]{0,63}$.
        # CodeQL cannot follow taint through constructor validation or _safe_path().
        config_file.write_text(config, encoding="utf-8")  # lgtm[py/path-injection]
        config_file.chmod(0o640)  # lgtm[py/path-injection]
        _LOGGER.info(
            "Generated nginx stream config for %s on port %d → %s",
            self.instance_name,
            self.listen_port,
            self.forward_address,
        )

    def generate_cover_site_config(
        self,
        config_file: Path,
        cert_path: str,
        key_path: str,
        server_name: str = "_",
    ) -> None:
        """Generate nginx HTTP config for the cover website."""
        import os as _os

        # Re-apply basename in local scope so CodeQL sees the sanitiser
        _inst = _os.path.basename(self.instance_name)  # CodeQL path-injection sanitiser

        # Security audit: _inst = os.path.basename(self.instance_name), validated by regex
        # in __init__. All path suffixes ("cover_site", "nginx_tmp", "index.html") are literals.
        cover_html_dir = Path(self.data_dir) / _inst / "cover_site"
        cover_html_dir.mkdir(parents=True, exist_ok=True)  # lgtm[py/path-injection]

        # Create nginx temp directories under the instance dir (avoids permission
        # issues with /var/lib/nginx/tmp which is owned by the nginx user)
        tmp_dir = Path(self.data_dir) / _inst / "nginx_tmp"  # lgtm[py/path-injection]
        tmp_dir.mkdir(parents=True, exist_ok=True)  # lgtm[py/path-injection]

        # Generate default cover site if it doesn't exist
        index_file = cover_html_dir / "index.html"
        if not index_file.exists():  # lgtm[py/path-injection]
            index_file.write_text(
                self._default_cover_html(), encoding="utf-8"
            )  # lgtm[py/path-injection]

        config = f"""# Cover website for {self.instance_name}
# Auto-generated by Squid Proxy Manager — do not edit manually
# Included from nginx_stream.conf — do not load standalone

http {{
    # Temp paths under instance dir (writable by the addon process)
    client_body_temp_path {tmp_dir}/client_body;
    proxy_temp_path {tmp_dir}/proxy;
    fastcgi_temp_path {tmp_dir}/fastcgi;
    uwsgi_temp_path {tmp_dir}/uwsgi;
    scgi_temp_path {tmp_dir}/scgi;

    # Logs under instance log dir (avoids /var/lib/nginx/logs permission issues)
    access_log off;
    error_log /dev/null;

    server {{
        listen 127.0.0.1:{self.cover_site_port} ssl;
        server_name {server_name};

        ssl_certificate {cert_path};
        ssl_certificate_key {key_path};
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;

        root {cover_html_dir};
        index index.html;

        location / {{
            try_files $uri $uri/ =404;
        }}
    }}
}}
"""
        config_file.write_text(config, encoding="utf-8")  # lgtm[py/path-injection]
        config_file.chmod(0o640)  # lgtm[py/path-injection]
        _LOGGER.info(
            "Generated cover site config for %s on 127.0.0.1:%d",
            self.instance_name,
            self.cover_site_port,
        )

    def _default_cover_html(self) -> str:
        """Minimal plausible website HTML."""
        return """<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Welcome</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
           display: flex; justify-content: center; align-items: center;
           min-height: 100vh; margin: 0; background: #f5f5f5; color: #333; }
    .container { text-align: center; padding: 2rem; }
    h1 { font-size: 2rem; margin-bottom: 0.5rem; }
    p { color: #666; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Welcome</h1>
    <p>This site is under construction. Please check back later.</p>
  </div>
</body>
</html>"""
